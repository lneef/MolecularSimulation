// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "molsim-pskel.h"

// simulation_pskel
//
namespace XMLReader {
    void simulation_pskel::
    t_end_parser(xml_schema::double_pskel &p) {
        this->t_end_parser_ = &p;
    }

    void simulation_pskel::
    delta_t_parser(xml_schema::double_pskel &p) {
        this->delta_t_parser_ = &p;
    }

    void simulation_pskel::
    domain_size_x_parser(xml_schema::double_pskel &p) {
        this->domain_size_x_parser_ = &p;
    }

    void simulation_pskel::
    domain_size_y_parser(xml_schema::double_pskel &p) {
        this->domain_size_y_parser_ = &p;
    }

    void simulation_pskel::
    domain_size_z_parser(xml_schema::double_pskel &p) {
        this->domain_size_z_parser_ = &p;
    }

    void simulation_pskel::
    cutOff_radius_parser(xml_schema::double_pskel &p) {
        this->cutOff_radius_parser_ = &p;
    }

    void simulation_pskel::
    output_name_parser(xml_schema::string_pskel &p) {
        this->output_name_parser_ = &p;
    }

    void simulation_pskel::
    output_frequency_parser(xml_schema::int_pskel &p) {
        this->output_frequency_parser_ = &p;
    }

    void simulation_pskel::
    g_gravitation_parser(xml_schema::double_pskel &p) {
        this->g_gravitation_parser_ = &p;
    }

    void simulation_pskel::
    parsers(xml_schema::double_pskel &t_end,
            xml_schema::double_pskel &delta_t,
            xml_schema::double_pskel &domain_size_x,
            xml_schema::double_pskel &domain_size_y,
            xml_schema::double_pskel &domain_size_z,
            xml_schema::double_pskel &cutOff_radius,
            xml_schema::string_pskel &output_name,
            xml_schema::int_pskel &output_frequency,
            xml_schema::double_pskel &g_gravitation) {
        this->t_end_parser_ = &t_end;
        this->delta_t_parser_ = &delta_t;
        this->domain_size_x_parser_ = &domain_size_x;
        this->domain_size_y_parser_ = &domain_size_y;
        this->domain_size_z_parser_ = &domain_size_z;
        this->cutOff_radius_parser_ = &cutOff_radius;
        this->output_name_parser_ = &output_name;
        this->output_frequency_parser_ = &output_frequency;
        this->g_gravitation_parser_ = &g_gravitation;
    }

    simulation_pskel::
    simulation_pskel()
            : t_end_parser_(0),
              delta_t_parser_(0),
              domain_size_x_parser_(0),
              domain_size_y_parser_(0),
              domain_size_z_parser_(0),
              cutOff_radius_parser_(0),
              output_name_parser_(0),
              output_frequency_parser_(0),
              g_gravitation_parser_(0) {
    }

// temperature_pskel
//

    void temperature_pskel::
    temp_int_parser(xml_schema::double_pskel &p) {
        this->temp_int_parser_ = &p;
    }

    void temperature_pskel::
    n_thermostat_parser(xml_schema::int_pskel &p) {
        this->n_thermostat_parser_ = &p;
    }

    void temperature_pskel::
    temp_target_parser(xml_schema::double_pskel &p) {
        this->temp_target_parser_ = &p;
    }

    void temperature_pskel::
    temp_delta_parser(xml_schema::double_pskel &p) {
        this->temp_delta_parser_ = &p;
    }

    void temperature_pskel::
    parsers(xml_schema::double_pskel &temp_int,
            xml_schema::int_pskel &n_thermostat,
            xml_schema::double_pskel &temp_target,
            xml_schema::double_pskel &temp_delta) {
        this->temp_int_parser_ = &temp_int;
        this->n_thermostat_parser_ = &n_thermostat;
        this->temp_target_parser_ = &temp_target;
        this->temp_delta_parser_ = &temp_delta;
    }

    temperature_pskel::
    temperature_pskel()
            : temp_int_parser_(0),
              n_thermostat_parser_(0),
              temp_target_parser_(0),
              temp_delta_parser_(0) {
    }

// cuboid_pskel
//

    void cuboid_pskel::
    type_parser(xml_schema::int_pskel &p) {
        this->type_parser_ = &p;
    }

    void cuboid_pskel::
    sigma_parser(xml_schema::double_pskel &p) {
        this->sigma_parser_ = &p;
    }

    void cuboid_pskel::
    epsilon_parser(xml_schema::double_pskel &p) {
        this->epsilon_parser_ = &p;
    }

    void cuboid_pskel::
    lower_left_x_parser(xml_schema::double_pskel &p) {
        this->lower_left_x_parser_ = &p;
    }

    void cuboid_pskel::
    lower_left_y_parser(xml_schema::double_pskel &p) {
        this->lower_left_y_parser_ = &p;
    }

    void cuboid_pskel::
    lower_left_z_parser(xml_schema::double_pskel &p) {
        this->lower_left_z_parser_ = &p;
    }

    void cuboid_pskel::
    number_x_parser(xml_schema::int_pskel &p) {
        this->number_x_parser_ = &p;
    }

    void cuboid_pskel::
    number_y_parser(xml_schema::int_pskel &p) {
        this->number_y_parser_ = &p;
    }

    void cuboid_pskel::
    number_z_parser(xml_schema::int_pskel &p) {
        this->number_z_parser_ = &p;
    }

    void cuboid_pskel::
    mesh_width_parser(xml_schema::double_pskel &p) {
        this->mesh_width_parser_ = &p;
    }

    void cuboid_pskel::
    mass_parser(xml_schema::double_pskel &p) {
        this->mass_parser_ = &p;
    }

    void cuboid_pskel::
    velocity_x_parser(xml_schema::double_pskel &p) {
        this->velocity_x_parser_ = &p;
    }

    void cuboid_pskel::
    velocity_y_parser(xml_schema::double_pskel &p) {
        this->velocity_y_parser_ = &p;
    }

    void cuboid_pskel::
    velocity_z_parser(xml_schema::double_pskel &p) {
        this->velocity_z_parser_ = &p;
    }

    void cuboid_pskel::
    brownianMotion_parser(xml_schema::boolean_pskel &p) {
        this->brownianMotion_parser_ = &p;
    }

    void cuboid_pskel::
    parsers(xml_schema::int_pskel &type,
            xml_schema::double_pskel &sigma,
            xml_schema::double_pskel &epsilon,
            xml_schema::double_pskel &lower_left_x,
            xml_schema::double_pskel &lower_left_y,
            xml_schema::double_pskel &lower_left_z,
            xml_schema::int_pskel &number_x,
            xml_schema::int_pskel &number_y,
            xml_schema::int_pskel &number_z,
            xml_schema::double_pskel &mesh_width,
            xml_schema::double_pskel &mass,
            xml_schema::double_pskel &velocity_x,
            xml_schema::double_pskel &velocity_y,
            xml_schema::double_pskel &velocity_z,
            xml_schema::boolean_pskel &brownianMotion) {
        this->type_parser_ = &type;
        this->sigma_parser_ = &sigma;
        this->epsilon_parser_ = &epsilon;
        this->lower_left_x_parser_ = &lower_left_x;
        this->lower_left_y_parser_ = &lower_left_y;
        this->lower_left_z_parser_ = &lower_left_z;
        this->number_x_parser_ = &number_x;
        this->number_y_parser_ = &number_y;
        this->number_z_parser_ = &number_z;
        this->mesh_width_parser_ = &mesh_width;
        this->mass_parser_ = &mass;
        this->velocity_x_parser_ = &velocity_x;
        this->velocity_y_parser_ = &velocity_y;
        this->velocity_z_parser_ = &velocity_z;
        this->brownianMotion_parser_ = &brownianMotion;
    }

    cuboid_pskel::
    cuboid_pskel()
            : type_parser_(0),
              sigma_parser_(0),
              epsilon_parser_(0),
              lower_left_x_parser_(0),
              lower_left_y_parser_(0),
              lower_left_z_parser_(0),
              number_x_parser_(0),
              number_y_parser_(0),
              number_z_parser_(0),
              mesh_width_parser_(0),
              mass_parser_(0),
              velocity_x_parser_(0),
              velocity_y_parser_(0),
              velocity_z_parser_(0),
              brownianMotion_parser_(0) {
    }

// membrane_pskel
//

    void membrane_pskel::
    sigma_parser(xml_schema::double_pskel &p) {
        this->sigma_parser_ = &p;
    }

    void membrane_pskel::
    epsilon_parser(xml_schema::double_pskel &p) {
        this->epsilon_parser_ = &p;
    }

    void membrane_pskel::
    lower_left_x_parser(xml_schema::double_pskel &p) {
        this->lower_left_x_parser_ = &p;
    }

    void membrane_pskel::
    lower_left_y_parser(xml_schema::double_pskel &p) {
        this->lower_left_y_parser_ = &p;
    }

    void membrane_pskel::
    lower_left_z_parser(xml_schema::double_pskel &p) {
        this->lower_left_z_parser_ = &p;
    }

    void membrane_pskel::
    number_x_parser(xml_schema::int_pskel &p) {
        this->number_x_parser_ = &p;
    }

    void membrane_pskel::
    number_y_parser(xml_schema::int_pskel &p) {
        this->number_y_parser_ = &p;
    }

    void membrane_pskel::
    number_z_parser(xml_schema::int_pskel &p) {
        this->number_z_parser_ = &p;
    }

    void membrane_pskel::
    mesh_width_parser(xml_schema::double_pskel &p) {
        this->mesh_width_parser_ = &p;
    }

    void membrane_pskel::
    mass_parser(xml_schema::double_pskel &p) {
        this->mass_parser_ = &p;
    }

    void membrane_pskel::
    velocity_x_parser(xml_schema::double_pskel &p) {
        this->velocity_x_parser_ = &p;
    }

    void membrane_pskel::
    velocity_y_parser(xml_schema::double_pskel &p) {
        this->velocity_y_parser_ = &p;
    }

    void membrane_pskel::
    velocity_z_parser(xml_schema::double_pskel &p) {
        this->velocity_z_parser_ = &p;
    }

    void membrane_pskel::
    brownianMotion_parser(xml_schema::boolean_pskel &p) {
        this->brownianMotion_parser_ = &p;
    }

    void membrane_pskel::
    fz_up_parser(xml_schema::double_pskel &p) {
        this->fz_up_parser_ = &p;
    }

    void membrane_pskel::
    stiffness_const_parser(xml_schema::double_pskel &p) {
        this->stiffness_const_parser_ = &p;
    }

    void membrane_pskel::
    bond_length_parser(xml_schema::double_pskel &p) {
        this->bond_length_parser_ = &p;
    }

    void membrane_pskel::
    parsers(xml_schema::double_pskel &sigma,
            xml_schema::double_pskel &epsilon,
            xml_schema::double_pskel &lower_left_x,
            xml_schema::double_pskel &lower_left_y,
            xml_schema::double_pskel &lower_left_z,
            xml_schema::int_pskel &number_x,
            xml_schema::int_pskel &number_y,
            xml_schema::int_pskel &number_z,
            xml_schema::double_pskel &mesh_width,
            xml_schema::double_pskel &mass,
            xml_schema::double_pskel &velocity_x,
            xml_schema::double_pskel &velocity_y,
            xml_schema::double_pskel &velocity_z,
            xml_schema::boolean_pskel &brownianMotion,
            xml_schema::double_pskel &fz_up,
            xml_schema::double_pskel &stiffness_const,
            xml_schema::double_pskel &bond_length) {
        this->sigma_parser_ = &sigma;
        this->epsilon_parser_ = &epsilon;
        this->lower_left_x_parser_ = &lower_left_x;
        this->lower_left_y_parser_ = &lower_left_y;
        this->lower_left_z_parser_ = &lower_left_z;
        this->number_x_parser_ = &number_x;
        this->number_y_parser_ = &number_y;
        this->number_z_parser_ = &number_z;
        this->mesh_width_parser_ = &mesh_width;
        this->mass_parser_ = &mass;
        this->velocity_x_parser_ = &velocity_x;
        this->velocity_y_parser_ = &velocity_y;
        this->velocity_z_parser_ = &velocity_z;
        this->brownianMotion_parser_ = &brownianMotion;
        this->fz_up_parser_ = &fz_up;
        this->stiffness_const_parser_ = &stiffness_const;
        this->bond_length_parser_ = &bond_length;
    }

    membrane_pskel::
    membrane_pskel()
            : sigma_parser_(0),
              epsilon_parser_(0),
              lower_left_x_parser_(0),
              lower_left_y_parser_(0),
              lower_left_z_parser_(0),
              number_x_parser_(0),
              number_y_parser_(0),
              number_z_parser_(0),
              mesh_width_parser_(0),
              mass_parser_(0),
              velocity_x_parser_(0),
              velocity_y_parser_(0),
              velocity_z_parser_(0),
              brownianMotion_parser_(0),
              fz_up_parser_(0),
              stiffness_const_parser_(0),
              bond_length_parser_(0) {
    }

// cuboid_input_pskel
//

    void cuboid_input_pskel::
    path_parser(xml_schema::string_pskel &p) {
        this->path_parser_ = &p;
    }

    void cuboid_input_pskel::
    parsers(xml_schema::string_pskel &path) {
        this->path_parser_ = &path;
    }

    cuboid_input_pskel::
    cuboid_input_pskel()
            : path_parser_(0) {
    }

// from_checkpoint_pskel
//

    void from_checkpoint_pskel::
    path_parser(xml_schema::string_pskel &p) {
        this->path_parser_ = &p;
    }

    void from_checkpoint_pskel::
    parsers(xml_schema::string_pskel &path) {
        this->path_parser_ = &path;
    }

    from_checkpoint_pskel::
    from_checkpoint_pskel()
            : path_parser_(0) {
    }

// sphere_pskel
//

    void sphere_pskel::
    type_parser(xml_schema::int_pskel &p) {
        this->type_parser_ = &p;
    }

    void sphere_pskel::
    sigma_parser(xml_schema::double_pskel &p) {
        this->sigma_parser_ = &p;
    }

    void sphere_pskel::
    epsilon_parser(xml_schema::double_pskel &p) {
        this->epsilon_parser_ = &p;
    }

    void sphere_pskel::
    center_x_parser(xml_schema::double_pskel &p) {
        this->center_x_parser_ = &p;
    }

    void sphere_pskel::
    center_y_parser(xml_schema::double_pskel &p) {
        this->center_y_parser_ = &p;
    }

    void sphere_pskel::
    center_z_parser(xml_schema::double_pskel &p) {
        this->center_z_parser_ = &p;
    }

    void sphere_pskel::
    radius_parser(xml_schema::int_pskel &p) {
        this->radius_parser_ = &p;
    }

    void sphere_pskel::
    mesh_width_parser(xml_schema::double_pskel &p) {
        this->mesh_width_parser_ = &p;
    }

    void sphere_pskel::
    mass_parser(xml_schema::double_pskel &p) {
        this->mass_parser_ = &p;
    }

    void sphere_pskel::
    velocity_x_parser(xml_schema::double_pskel &p) {
        this->velocity_x_parser_ = &p;
    }

    void sphere_pskel::
    velocity_y_parser(xml_schema::double_pskel &p) {
        this->velocity_y_parser_ = &p;
    }

    void sphere_pskel::
    velocity_z_parser(xml_schema::double_pskel &p) {
        this->velocity_z_parser_ = &p;
    }

    void sphere_pskel::
    brownianMotion_parser(xml_schema::boolean_pskel &p) {
        this->brownianMotion_parser_ = &p;
    }

    void sphere_pskel::
    parsers(xml_schema::int_pskel &type,
            xml_schema::double_pskel &sigma,
            xml_schema::double_pskel &epsilon,
            xml_schema::double_pskel &center_x,
            xml_schema::double_pskel &center_y,
            xml_schema::double_pskel &center_z,
            xml_schema::int_pskel &radius,
            xml_schema::double_pskel &mesh_width,
            xml_schema::double_pskel &mass,
            xml_schema::double_pskel &velocity_x,
            xml_schema::double_pskel &velocity_y,
            xml_schema::double_pskel &velocity_z,
            xml_schema::boolean_pskel &brownianMotion) {
        this->type_parser_ = &type;
        this->sigma_parser_ = &sigma;
        this->epsilon_parser_ = &epsilon;
        this->center_x_parser_ = &center_x;
        this->center_y_parser_ = &center_y;
        this->center_z_parser_ = &center_z;
        this->radius_parser_ = &radius;
        this->mesh_width_parser_ = &mesh_width;
        this->mass_parser_ = &mass;
        this->velocity_x_parser_ = &velocity_x;
        this->velocity_y_parser_ = &velocity_y;
        this->velocity_z_parser_ = &velocity_z;
        this->brownianMotion_parser_ = &brownianMotion;
    }

    sphere_pskel::
    sphere_pskel()
            : type_parser_(0),
              sigma_parser_(0),
              epsilon_parser_(0),
              center_x_parser_(0),
              center_y_parser_(0),
              center_z_parser_(0),
              radius_parser_(0),
              mesh_width_parser_(0),
              mass_parser_(0),
              velocity_x_parser_(0),
              velocity_y_parser_(0),
              velocity_z_parser_(0),
              brownianMotion_parser_(0) {
    }

// spheres_input_pskel
//

    void spheres_input_pskel::
    path_parser(xml_schema::string_pskel &p) {
        this->path_parser_ = &p;
    }

    void spheres_input_pskel::
    parsers(xml_schema::string_pskel &path) {
        this->path_parser_ = &path;
    }

    spheres_input_pskel::
    spheres_input_pskel()
            : path_parser_(0) {
    }

// boundaries_pskel
//

    void boundaries_pskel::
    top_boundary_parser(xml_schema::string_pskel &p) {
        this->top_boundary_parser_ = &p;
    }

    void boundaries_pskel::
    bottom_boundary_parser(xml_schema::string_pskel &p) {
        this->bottom_boundary_parser_ = &p;
    }

    void boundaries_pskel::
    left_boundary_parser(xml_schema::string_pskel &p) {
        this->left_boundary_parser_ = &p;
    }

    void boundaries_pskel::
    right_boundary_parser(xml_schema::string_pskel &p) {
        this->right_boundary_parser_ = &p;
    }

    void boundaries_pskel::
    parsers(xml_schema::string_pskel &top_boundary,
            xml_schema::string_pskel &bottom_boundary,
            xml_schema::string_pskel &left_boundary,
            xml_schema::string_pskel &right_boundary) {
        this->top_boundary_parser_ = &top_boundary;
        this->bottom_boundary_parser_ = &bottom_boundary;
        this->left_boundary_parser_ = &left_boundary;
        this->right_boundary_parser_ = &right_boundary;
    }

    boundaries_pskel::
    boundaries_pskel()
            : top_boundary_parser_(0),
              bottom_boundary_parser_(0),
              left_boundary_parser_(0),
              right_boundary_parser_(0) {
    }

// molecular_pskel
//

    void molecular_pskel::
    cuboid_parser(cuboid_pskel &p) {
        this->cuboid_parser_ = &p;
    }

    void molecular_pskel::
    simulation_parser(simulation_pskel &p) {
        this->simulation_parser_ = &p;
    }

    void molecular_pskel::
    cuboid_input_parser(cuboid_input_pskel &p) {
        this->cuboid_input_parser_ = &p;
    }

    void molecular_pskel::
    sphere_parser(sphere_pskel &p) {
        this->sphere_parser_ = &p;
    }

    void molecular_pskel::
    spheres_input_parser(spheres_input_pskel &p) {
        this->spheres_input_parser_ = &p;
    }

    void molecular_pskel::
    boundaries_parser(boundaries_pskel &p) {
        this->boundaries_parser_ = &p;
    }

    void molecular_pskel::
    temperature_parser(temperature_pskel &p) {
        this->temperature_parser_ = &p;
    }

    void molecular_pskel::
    from_checkpoint_parser(from_checkpoint_pskel &p) {
        this->from_checkpoint_parser_ = &p;
    }

    void molecular_pskel::
    membrane_parser(membrane_pskel &p) {
        this->membrane_parser_ = &p;
    }

    void molecular_pskel::
    parsers(cuboid_pskel &cuboid,
            simulation_pskel &simulation,
            cuboid_input_pskel &cuboid_input,
            sphere_pskel &sphere,
            spheres_input_pskel &spheres_input,
            boundaries_pskel &boundaries,
            temperature_pskel &temperature,
            from_checkpoint_pskel &from_checkpoint,
            membrane_pskel &membrane) {
        this->cuboid_parser_ = &cuboid;
        this->simulation_parser_ = &simulation;
        this->cuboid_input_parser_ = &cuboid_input;
        this->sphere_parser_ = &sphere;
        this->spheres_input_parser_ = &spheres_input;
        this->boundaries_parser_ = &boundaries;
        this->temperature_parser_ = &temperature;
        this->from_checkpoint_parser_ = &from_checkpoint;
        this->membrane_parser_ = &membrane;
    }

    molecular_pskel::
    molecular_pskel()
            : cuboid_parser_(0),
              simulation_parser_(0),
              cuboid_input_parser_(0),
              sphere_parser_(0),
              spheres_input_parser_(0),
              boundaries_parser_(0),
              temperature_parser_(0),
              from_checkpoint_parser_(0),
              membrane_parser_(0) {
    }

// simulation_pskel
//

    void simulation_pskel::
    t_end(double) {
    }

    void simulation_pskel::
    delta_t(double) {
    }

    void simulation_pskel::
    domain_size_x(double) {
    }

    void simulation_pskel::
    domain_size_y(double) {
    }

    void simulation_pskel::
    domain_size_z(double) {
    }

    void simulation_pskel::
    cutOff_radius(double) {
    }

    void simulation_pskel::
    output_name(const ::std::string &) {
    }

    void simulation_pskel::
    output_frequency(int) {
    }

    void simulation_pskel::
    g_gravitation(double) {
    }

    void simulation_pskel::
    post_simulation() {
    }

    bool simulation_pskel::
    _start_element_impl(const xml_schema::ro_string &ns,
                        const xml_schema::ro_string &n,
                        const xml_schema::ro_string *t) {
        XSD_UNUSED (t);

        if (this->xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;

        if (n == "t_end" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->t_end_parser_;

            if (this->t_end_parser_)
                this->t_end_parser_->pre();

            return true;
        }

        if (n == "delta_t" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->delta_t_parser_;

            if (this->delta_t_parser_)
                this->delta_t_parser_->pre();

            return true;
        }

        if (n == "domain_size_x" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->domain_size_x_parser_;

            if (this->domain_size_x_parser_)
                this->domain_size_x_parser_->pre();

            return true;
        }

        if (n == "domain_size_y" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->domain_size_y_parser_;

            if (this->domain_size_y_parser_)
                this->domain_size_y_parser_->pre();

            return true;
        }

        if (n == "domain_size_z" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->domain_size_z_parser_;

            if (this->domain_size_z_parser_)
                this->domain_size_z_parser_->pre();

            return true;
        }

        if (n == "cutOff_radius" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->cutOff_radius_parser_;

            if (this->cutOff_radius_parser_)
                this->cutOff_radius_parser_->pre();

            return true;
        }

        if (n == "output_name" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->output_name_parser_;

            if (this->output_name_parser_)
                this->output_name_parser_->pre();

            return true;
        }

        if (n == "output_frequency" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->output_frequency_parser_;

            if (this->output_frequency_parser_)
                this->output_frequency_parser_->pre();

            return true;
        }

        if (n == "g_gravitation" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->g_gravitation_parser_;

            if (this->g_gravitation_parser_)
                this->g_gravitation_parser_->pre();

            return true;
        }

        return false;
    }

    bool simulation_pskel::
    _end_element_impl(const xml_schema::ro_string &ns,
                      const xml_schema::ro_string &n) {
        if (this->xml_schema::complex_content::_end_element_impl(ns, n))
            return true;

        if (n == "t_end" && ns.empty()) {
            if (this->t_end_parser_)
                this->t_end(this->t_end_parser_->post_double());

            return true;
        }

        if (n == "delta_t" && ns.empty()) {
            if (this->delta_t_parser_)
                this->delta_t(this->delta_t_parser_->post_double());

            return true;
        }

        if (n == "domain_size_x" && ns.empty()) {
            if (this->domain_size_x_parser_)
                this->domain_size_x(this->domain_size_x_parser_->post_double());

            return true;
        }

        if (n == "domain_size_y" && ns.empty()) {
            if (this->domain_size_y_parser_)
                this->domain_size_y(this->domain_size_y_parser_->post_double());

            return true;
        }

        if (n == "domain_size_z" && ns.empty()) {
            if (this->domain_size_z_parser_)
                this->domain_size_z(this->domain_size_z_parser_->post_double());

            return true;
        }

        if (n == "cutOff_radius" && ns.empty()) {
            if (this->cutOff_radius_parser_)
                this->cutOff_radius(this->cutOff_radius_parser_->post_double());

            return true;
        }

        if (n == "output_name" && ns.empty()) {
            if (this->output_name_parser_)
                this->output_name(this->output_name_parser_->post_string());

            return true;
        }

        if (n == "output_frequency" && ns.empty()) {
            if (this->output_frequency_parser_)
                this->output_frequency(this->output_frequency_parser_->post_int());

            return true;
        }

        if (n == "g_gravitation" && ns.empty()) {
            if (this->g_gravitation_parser_)
                this->g_gravitation(this->g_gravitation_parser_->post_double());

            return true;
        }

        return false;
    }

// temperature_pskel
//

    void temperature_pskel::
    temp_int(double) {
    }

    void temperature_pskel::
    n_thermostat(int) {
    }

    void temperature_pskel::
    temp_target(double) {
    }

    void temperature_pskel::
    temp_delta(double) {
    }

    void temperature_pskel::
    post_temperature() {
    }

    bool temperature_pskel::
    _start_element_impl(const xml_schema::ro_string &ns,
                        const xml_schema::ro_string &n,
                        const xml_schema::ro_string *t) {
        XSD_UNUSED (t);

        if (this->xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;

        if (n == "temp_int" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->temp_int_parser_;

            if (this->temp_int_parser_)
                this->temp_int_parser_->pre();

            return true;
        }

        if (n == "n_thermostat" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->n_thermostat_parser_;

            if (this->n_thermostat_parser_)
                this->n_thermostat_parser_->pre();

            return true;
        }

        if (n == "temp_target" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->temp_target_parser_;

            if (this->temp_target_parser_)
                this->temp_target_parser_->pre();

            return true;
        }

        if (n == "temp_delta" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->temp_delta_parser_;

            if (this->temp_delta_parser_)
                this->temp_delta_parser_->pre();

            return true;
        }

        return false;
    }

    bool temperature_pskel::
    _end_element_impl(const xml_schema::ro_string &ns,
                      const xml_schema::ro_string &n) {
        if (this->xml_schema::complex_content::_end_element_impl(ns, n))
            return true;

        if (n == "temp_int" && ns.empty()) {
            if (this->temp_int_parser_)
                this->temp_int(this->temp_int_parser_->post_double());

            return true;
        }

        if (n == "n_thermostat" && ns.empty()) {
            if (this->n_thermostat_parser_)
                this->n_thermostat(this->n_thermostat_parser_->post_int());

            return true;
        }

        if (n == "temp_target" && ns.empty()) {
            if (this->temp_target_parser_)
                this->temp_target(this->temp_target_parser_->post_double());

            return true;
        }

        if (n == "temp_delta" && ns.empty()) {
            if (this->temp_delta_parser_)
                this->temp_delta(this->temp_delta_parser_->post_double());

            return true;
        }

        return false;
    }

// cuboid_pskel
//

    void cuboid_pskel::
    type(int) {
    }

    void cuboid_pskel::
    sigma(double) {
    }

    void cuboid_pskel::
    epsilon(double) {
    }

    void cuboid_pskel::
    lower_left_x(double) {
    }

    void cuboid_pskel::
    lower_left_y(double) {
    }

    void cuboid_pskel::
    lower_left_z(double) {
    }

    void cuboid_pskel::
    number_x(int) {
    }

    void cuboid_pskel::
    number_y(int) {
    }

    void cuboid_pskel::
    number_z(int) {
    }

    void cuboid_pskel::
    mesh_width(double) {
    }

    void cuboid_pskel::
    mass(double) {
    }

    void cuboid_pskel::
    velocity_x(double) {
    }

    void cuboid_pskel::
    velocity_y(double) {
    }

    void cuboid_pskel::
    velocity_z(double) {
    }

    void cuboid_pskel::
    brownianMotion(bool) {
    }

    void cuboid_pskel::
    post_cuboid() {
    }

    bool cuboid_pskel::
    _start_element_impl(const xml_schema::ro_string &ns,
                        const xml_schema::ro_string &n,
                        const xml_schema::ro_string *t) {
        XSD_UNUSED (t);

        if (this->xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;

        if (n == "type" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->type_parser_;

            if (this->type_parser_)
                this->type_parser_->pre();

            return true;
        }

        if (n == "sigma" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->sigma_parser_;

            if (this->sigma_parser_)
                this->sigma_parser_->pre();

            return true;
        }

        if (n == "epsilon" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->epsilon_parser_;

            if (this->epsilon_parser_)
                this->epsilon_parser_->pre();

            return true;
        }

        if (n == "lower_left_x" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->lower_left_x_parser_;

            if (this->lower_left_x_parser_)
                this->lower_left_x_parser_->pre();

            return true;
        }

        if (n == "lower_left_y" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->lower_left_y_parser_;

            if (this->lower_left_y_parser_)
                this->lower_left_y_parser_->pre();

            return true;
        }

        if (n == "lower_left_z" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->lower_left_z_parser_;

            if (this->lower_left_z_parser_)
                this->lower_left_z_parser_->pre();

            return true;
        }

        if (n == "number_x" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->number_x_parser_;

            if (this->number_x_parser_)
                this->number_x_parser_->pre();

            return true;
        }

        if (n == "number_y" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->number_y_parser_;

            if (this->number_y_parser_)
                this->number_y_parser_->pre();

            return true;
        }

        if (n == "number_z" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->number_z_parser_;

            if (this->number_z_parser_)
                this->number_z_parser_->pre();

            return true;
        }

        if (n == "mesh_width" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->mesh_width_parser_;

            if (this->mesh_width_parser_)
                this->mesh_width_parser_->pre();

            return true;
        }

        if (n == "mass" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->mass_parser_;

            if (this->mass_parser_)
                this->mass_parser_->pre();

            return true;
        }

        if (n == "velocity_x" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->velocity_x_parser_;

            if (this->velocity_x_parser_)
                this->velocity_x_parser_->pre();

            return true;
        }

        if (n == "velocity_y" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->velocity_y_parser_;

            if (this->velocity_y_parser_)
                this->velocity_y_parser_->pre();

            return true;
        }

        if (n == "velocity_z" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->velocity_z_parser_;

            if (this->velocity_z_parser_)
                this->velocity_z_parser_->pre();

            return true;
        }

        if (n == "brownianMotion" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->brownianMotion_parser_;

            if (this->brownianMotion_parser_)
                this->brownianMotion_parser_->pre();

            return true;
        }

        return false;
    }

    bool cuboid_pskel::
    _end_element_impl(const xml_schema::ro_string &ns,
                      const xml_schema::ro_string &n) {
        if (this->xml_schema::complex_content::_end_element_impl(ns, n))
            return true;

        if (n == "type" && ns.empty()) {
            if (this->type_parser_)
                this->type(this->type_parser_->post_int());

            return true;
        }

        if (n == "sigma" && ns.empty()) {
            if (this->sigma_parser_)
                this->sigma(this->sigma_parser_->post_double());

            return true;
        }

        if (n == "epsilon" && ns.empty()) {
            if (this->epsilon_parser_)
                this->epsilon(this->epsilon_parser_->post_double());

            return true;
        }

        if (n == "lower_left_x" && ns.empty()) {
            if (this->lower_left_x_parser_)
                this->lower_left_x(this->lower_left_x_parser_->post_double());

            return true;
        }

        if (n == "lower_left_y" && ns.empty()) {
            if (this->lower_left_y_parser_)
                this->lower_left_y(this->lower_left_y_parser_->post_double());

            return true;
        }

        if (n == "lower_left_z" && ns.empty()) {
            if (this->lower_left_z_parser_)
                this->lower_left_z(this->lower_left_z_parser_->post_double());

            return true;
        }

        if (n == "number_x" && ns.empty()) {
            if (this->number_x_parser_)
                this->number_x(this->number_x_parser_->post_int());

            return true;
        }

        if (n == "number_y" && ns.empty()) {
            if (this->number_y_parser_)
                this->number_y(this->number_y_parser_->post_int());

            return true;
        }

        if (n == "number_z" && ns.empty()) {
            if (this->number_z_parser_)
                this->number_z(this->number_z_parser_->post_int());

            return true;
        }

        if (n == "mesh_width" && ns.empty()) {
            if (this->mesh_width_parser_)
                this->mesh_width(this->mesh_width_parser_->post_double());

            return true;
        }

        if (n == "mass" && ns.empty()) {
            if (this->mass_parser_)
                this->mass(this->mass_parser_->post_double());

            return true;
        }

        if (n == "velocity_x" && ns.empty()) {
            if (this->velocity_x_parser_)
                this->velocity_x(this->velocity_x_parser_->post_double());

            return true;
        }

        if (n == "velocity_y" && ns.empty()) {
            if (this->velocity_y_parser_)
                this->velocity_y(this->velocity_y_parser_->post_double());

            return true;
        }

        if (n == "velocity_z" && ns.empty()) {
            if (this->velocity_z_parser_)
                this->velocity_z(this->velocity_z_parser_->post_double());

            return true;
        }

        if (n == "brownianMotion" && ns.empty()) {
            if (this->brownianMotion_parser_)
                this->brownianMotion(this->brownianMotion_parser_->post_boolean());

            return true;
        }

        return false;
    }

// membrane_pskel
//

    void membrane_pskel::
    sigma(double) {
    }

    void membrane_pskel::
    epsilon(double) {
    }

    void membrane_pskel::
    lower_left_x(double) {
    }

    void membrane_pskel::
    lower_left_y(double) {
    }

    void membrane_pskel::
    lower_left_z(double) {
    }

    void membrane_pskel::
    number_x(int) {
    }

    void membrane_pskel::
    number_y(int) {
    }

    void membrane_pskel::
    number_z(int) {
    }

    void membrane_pskel::
    mesh_width(double) {
    }

    void membrane_pskel::
    mass(double) {
    }

    void membrane_pskel::
    velocity_x(double) {
    }

    void membrane_pskel::
    velocity_y(double) {
    }

    void membrane_pskel::
    velocity_z(double) {
    }

    void membrane_pskel::
    brownianMotion(bool) {
    }

    void membrane_pskel::
    fz_up(double) {
    }

    void membrane_pskel::
    stiffness_const(double) {
    }

    void membrane_pskel::
    bond_length(double) {
    }

    void membrane_pskel::
    post_membrane() {
    }

    bool membrane_pskel::
    _start_element_impl(const xml_schema::ro_string &ns,
                        const xml_schema::ro_string &n,
                        const xml_schema::ro_string *t) {
        XSD_UNUSED (t);

        if (this->xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;

        if (n == "sigma" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->sigma_parser_;

            if (this->sigma_parser_)
                this->sigma_parser_->pre();

            return true;
        }

        if (n == "epsilon" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->epsilon_parser_;

            if (this->epsilon_parser_)
                this->epsilon_parser_->pre();

            return true;
        }

        if (n == "lower_left_x" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->lower_left_x_parser_;

            if (this->lower_left_x_parser_)
                this->lower_left_x_parser_->pre();

            return true;
        }

        if (n == "lower_left_y" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->lower_left_y_parser_;

            if (this->lower_left_y_parser_)
                this->lower_left_y_parser_->pre();

            return true;
        }

        if (n == "lower_left_z" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->lower_left_z_parser_;

            if (this->lower_left_z_parser_)
                this->lower_left_z_parser_->pre();

            return true;
        }

        if (n == "number_x" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->number_x_parser_;

            if (this->number_x_parser_)
                this->number_x_parser_->pre();

            return true;
        }

        if (n == "number_y" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->number_y_parser_;

            if (this->number_y_parser_)
                this->number_y_parser_->pre();

            return true;
        }

        if (n == "number_z" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->number_z_parser_;

            if (this->number_z_parser_)
                this->number_z_parser_->pre();

            return true;
        }

        if (n == "mesh_width" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->mesh_width_parser_;

            if (this->mesh_width_parser_)
                this->mesh_width_parser_->pre();

            return true;
        }

        if (n == "mass" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->mass_parser_;

            if (this->mass_parser_)
                this->mass_parser_->pre();

            return true;
        }

        if (n == "velocity_x" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->velocity_x_parser_;

            if (this->velocity_x_parser_)
                this->velocity_x_parser_->pre();

            return true;
        }

        if (n == "velocity_y" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->velocity_y_parser_;

            if (this->velocity_y_parser_)
                this->velocity_y_parser_->pre();

            return true;
        }

        if (n == "velocity_z" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->velocity_z_parser_;

            if (this->velocity_z_parser_)
                this->velocity_z_parser_->pre();

            return true;
        }

        if (n == "brownianMotion" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->brownianMotion_parser_;

            if (this->brownianMotion_parser_)
                this->brownianMotion_parser_->pre();

            return true;
        }

        if (n == "fz_up" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->fz_up_parser_;

            if (this->fz_up_parser_)
                this->fz_up_parser_->pre();

            return true;
        }

        if (n == "stiffness_const" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->stiffness_const_parser_;

            if (this->stiffness_const_parser_)
                this->stiffness_const_parser_->pre();

            return true;
        }

        if (n == "bond_length" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->bond_length_parser_;

            if (this->bond_length_parser_)
                this->bond_length_parser_->pre();

            return true;
        }

        return false;
    }

    bool membrane_pskel::
    _end_element_impl(const xml_schema::ro_string &ns,
                      const xml_schema::ro_string &n) {
        if (this->xml_schema::complex_content::_end_element_impl(ns, n))
            return true;

        if (n == "sigma" && ns.empty()) {
            if (this->sigma_parser_)
                this->sigma(this->sigma_parser_->post_double());

            return true;
        }

        if (n == "epsilon" && ns.empty()) {
            if (this->epsilon_parser_)
                this->epsilon(this->epsilon_parser_->post_double());

            return true;
        }

        if (n == "lower_left_x" && ns.empty()) {
            if (this->lower_left_x_parser_)
                this->lower_left_x(this->lower_left_x_parser_->post_double());

            return true;
        }

        if (n == "lower_left_y" && ns.empty()) {
            if (this->lower_left_y_parser_)
                this->lower_left_y(this->lower_left_y_parser_->post_double());

            return true;
        }

        if (n == "lower_left_z" && ns.empty()) {
            if (this->lower_left_z_parser_)
                this->lower_left_z(this->lower_left_z_parser_->post_double());

            return true;
        }

        if (n == "number_x" && ns.empty()) {
            if (this->number_x_parser_)
                this->number_x(this->number_x_parser_->post_int());

            return true;
        }

        if (n == "number_y" && ns.empty()) {
            if (this->number_y_parser_)
                this->number_y(this->number_y_parser_->post_int());

            return true;
        }

        if (n == "number_z" && ns.empty()) {
            if (this->number_z_parser_)
                this->number_z(this->number_z_parser_->post_int());

            return true;
        }

        if (n == "mesh_width" && ns.empty()) {
            if (this->mesh_width_parser_)
                this->mesh_width(this->mesh_width_parser_->post_double());

            return true;
        }

        if (n == "mass" && ns.empty()) {
            if (this->mass_parser_)
                this->mass(this->mass_parser_->post_double());

            return true;
        }

        if (n == "velocity_x" && ns.empty()) {
            if (this->velocity_x_parser_)
                this->velocity_x(this->velocity_x_parser_->post_double());

            return true;
        }

        if (n == "velocity_y" && ns.empty()) {
            if (this->velocity_y_parser_)
                this->velocity_y(this->velocity_y_parser_->post_double());

            return true;
        }

        if (n == "velocity_z" && ns.empty()) {
            if (this->velocity_z_parser_)
                this->velocity_z(this->velocity_z_parser_->post_double());

            return true;
        }

        if (n == "brownianMotion" && ns.empty()) {
            if (this->brownianMotion_parser_)
                this->brownianMotion(this->brownianMotion_parser_->post_boolean());

            return true;
        }

        if (n == "fz_up" && ns.empty()) {
            if (this->fz_up_parser_)
                this->fz_up(this->fz_up_parser_->post_double());

            return true;
        }

        if (n == "stiffness_const" && ns.empty()) {
            if (this->stiffness_const_parser_)
                this->stiffness_const(this->stiffness_const_parser_->post_double());

            return true;
        }

        if (n == "bond_length" && ns.empty()) {
            if (this->bond_length_parser_)
                this->bond_length(this->bond_length_parser_->post_double());

            return true;
        }

        return false;
    }

// cuboid_input_pskel
//

    void cuboid_input_pskel::
    path(const ::std::string &) {
    }

    void cuboid_input_pskel::
    post_cuboid_input() {
    }

    bool cuboid_input_pskel::
    _start_element_impl(const xml_schema::ro_string &ns,
                        const xml_schema::ro_string &n,
                        const xml_schema::ro_string *t) {
        XSD_UNUSED (t);

        if (this->xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;

        if (n == "path" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->path_parser_;

            if (this->path_parser_)
                this->path_parser_->pre();

            return true;
        }

        return false;
    }

    bool cuboid_input_pskel::
    _end_element_impl(const xml_schema::ro_string &ns,
                      const xml_schema::ro_string &n) {
        if (this->xml_schema::complex_content::_end_element_impl(ns, n))
            return true;

        if (n == "path" && ns.empty()) {
            if (this->path_parser_)
                this->path(this->path_parser_->post_string());

            return true;
        }

        return false;
    }

// from_checkpoint_pskel
//

    void from_checkpoint_pskel::
    path(const ::std::string &) {
    }

    void from_checkpoint_pskel::
    post_from_checkpoint() {
    }

    bool from_checkpoint_pskel::
    _start_element_impl(const xml_schema::ro_string &ns,
                        const xml_schema::ro_string &n,
                        const xml_schema::ro_string *t) {
        XSD_UNUSED (t);

        if (this->xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;

        if (n == "path" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->path_parser_;

            if (this->path_parser_)
                this->path_parser_->pre();

            return true;
        }

        return false;
    }

    bool from_checkpoint_pskel::
    _end_element_impl(const xml_schema::ro_string &ns,
                      const xml_schema::ro_string &n) {
        if (this->xml_schema::complex_content::_end_element_impl(ns, n))
            return true;

        if (n == "path" && ns.empty()) {
            if (this->path_parser_)
                this->path(this->path_parser_->post_string());

            return true;
        }

        return false;
    }

// sphere_pskel
//

    void sphere_pskel::
    type(int) {
    }

    void sphere_pskel::
    sigma(double) {
    }

    void sphere_pskel::
    epsilon(double) {
    }

    void sphere_pskel::
    center_x(double) {
    }

    void sphere_pskel::
    center_y(double) {
    }

    void sphere_pskel::
    center_z(double) {
    }

    void sphere_pskel::
    radius(int) {
    }

    void sphere_pskel::
    mesh_width(double) {
    }

    void sphere_pskel::
    mass(double) {
    }

    void sphere_pskel::
    velocity_x(double) {
    }

    void sphere_pskel::
    velocity_y(double) {
    }

    void sphere_pskel::
    velocity_z(double) {
    }

    void sphere_pskel::
    brownianMotion(bool) {
    }

    void sphere_pskel::
    post_sphere() {
    }

    bool sphere_pskel::
    _start_element_impl(const xml_schema::ro_string &ns,
                        const xml_schema::ro_string &n,
                        const xml_schema::ro_string *t) {
        XSD_UNUSED (t);

        if (this->xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;

        if (n == "type" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->type_parser_;

            if (this->type_parser_)
                this->type_parser_->pre();

            return true;
        }

        if (n == "sigma" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->sigma_parser_;

            if (this->sigma_parser_)
                this->sigma_parser_->pre();

            return true;
        }

        if (n == "epsilon" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->epsilon_parser_;

            if (this->epsilon_parser_)
                this->epsilon_parser_->pre();

            return true;
        }

        if (n == "center_x" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->center_x_parser_;

            if (this->center_x_parser_)
                this->center_x_parser_->pre();

            return true;
        }

        if (n == "center_y" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->center_y_parser_;

            if (this->center_y_parser_)
                this->center_y_parser_->pre();

            return true;
        }

        if (n == "center_z" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->center_z_parser_;

            if (this->center_z_parser_)
                this->center_z_parser_->pre();

            return true;
        }

        if (n == "radius" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->radius_parser_;

            if (this->radius_parser_)
                this->radius_parser_->pre();

            return true;
        }

        if (n == "mesh_width" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->mesh_width_parser_;

            if (this->mesh_width_parser_)
                this->mesh_width_parser_->pre();

            return true;
        }

        if (n == "mass" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->mass_parser_;

            if (this->mass_parser_)
                this->mass_parser_->pre();

            return true;
        }

        if (n == "velocity_x" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->velocity_x_parser_;

            if (this->velocity_x_parser_)
                this->velocity_x_parser_->pre();

            return true;
        }

        if (n == "velocity_y" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->velocity_y_parser_;

            if (this->velocity_y_parser_)
                this->velocity_y_parser_->pre();

            return true;
        }

        if (n == "velocity_z" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->velocity_z_parser_;

            if (this->velocity_z_parser_)
                this->velocity_z_parser_->pre();

            return true;
        }

        if (n == "brownianMotion" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->brownianMotion_parser_;

            if (this->brownianMotion_parser_)
                this->brownianMotion_parser_->pre();

            return true;
        }

        return false;
    }

    bool sphere_pskel::
    _end_element_impl(const xml_schema::ro_string &ns,
                      const xml_schema::ro_string &n) {
        if (this->xml_schema::complex_content::_end_element_impl(ns, n))
            return true;

        if (n == "type" && ns.empty()) {
            if (this->type_parser_)
                this->type(this->type_parser_->post_int());

            return true;
        }

        if (n == "sigma" && ns.empty()) {
            if (this->sigma_parser_)
                this->sigma(this->sigma_parser_->post_double());

            return true;
        }

        if (n == "epsilon" && ns.empty()) {
            if (this->epsilon_parser_)
                this->epsilon(this->epsilon_parser_->post_double());

            return true;
        }

        if (n == "center_x" && ns.empty()) {
            if (this->center_x_parser_)
                this->center_x(this->center_x_parser_->post_double());

            return true;
        }

        if (n == "center_y" && ns.empty()) {
            if (this->center_y_parser_)
                this->center_y(this->center_y_parser_->post_double());

            return true;
        }

        if (n == "center_z" && ns.empty()) {
            if (this->center_z_parser_)
                this->center_z(this->center_z_parser_->post_double());

            return true;
        }

        if (n == "radius" && ns.empty()) {
            if (this->radius_parser_)
                this->radius(this->radius_parser_->post_int());

            return true;
        }

        if (n == "mesh_width" && ns.empty()) {
            if (this->mesh_width_parser_)
                this->mesh_width(this->mesh_width_parser_->post_double());

            return true;
        }

        if (n == "mass" && ns.empty()) {
            if (this->mass_parser_)
                this->mass(this->mass_parser_->post_double());

            return true;
        }

        if (n == "velocity_x" && ns.empty()) {
            if (this->velocity_x_parser_)
                this->velocity_x(this->velocity_x_parser_->post_double());

            return true;
        }

        if (n == "velocity_y" && ns.empty()) {
            if (this->velocity_y_parser_)
                this->velocity_y(this->velocity_y_parser_->post_double());

            return true;
        }

        if (n == "velocity_z" && ns.empty()) {
            if (this->velocity_z_parser_)
                this->velocity_z(this->velocity_z_parser_->post_double());

            return true;
        }

        if (n == "brownianMotion" && ns.empty()) {
            if (this->brownianMotion_parser_)
                this->brownianMotion(this->brownianMotion_parser_->post_boolean());

            return true;
        }

        return false;
    }

// spheres_input_pskel
//

    void spheres_input_pskel::
    path(const ::std::string &) {
    }

    void spheres_input_pskel::
    post_spheres_input() {
    }

    bool spheres_input_pskel::
    _start_element_impl(const xml_schema::ro_string &ns,
                        const xml_schema::ro_string &n,
                        const xml_schema::ro_string *t) {
        XSD_UNUSED (t);

        if (this->xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;

        if (n == "path" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->path_parser_;

            if (this->path_parser_)
                this->path_parser_->pre();

            return true;
        }

        return false;
    }

    bool spheres_input_pskel::
    _end_element_impl(const xml_schema::ro_string &ns,
                      const xml_schema::ro_string &n) {
        if (this->xml_schema::complex_content::_end_element_impl(ns, n))
            return true;

        if (n == "path" && ns.empty()) {
            if (this->path_parser_)
                this->path(this->path_parser_->post_string());

            return true;
        }

        return false;
    }

// boundaries_pskel
//

    void boundaries_pskel::
    top_boundary(const ::std::string &) {
    }

    void boundaries_pskel::
    bottom_boundary(const ::std::string &) {
    }

    void boundaries_pskel::
    left_boundary(const ::std::string &) {
    }

    void boundaries_pskel::
    right_boundary(const ::std::string &) {
    }

    void boundaries_pskel::
    post_boundaries() {
    }

    bool boundaries_pskel::
    _start_element_impl(const xml_schema::ro_string &ns,
                        const xml_schema::ro_string &n,
                        const xml_schema::ro_string *t) {
        XSD_UNUSED (t);

        if (this->xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;

        if (n == "top_boundary" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->top_boundary_parser_;

            if (this->top_boundary_parser_)
                this->top_boundary_parser_->pre();

            return true;
        }

        if (n == "bottom_boundary" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->bottom_boundary_parser_;

            if (this->bottom_boundary_parser_)
                this->bottom_boundary_parser_->pre();

            return true;
        }

        if (n == "left_boundary" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->left_boundary_parser_;

            if (this->left_boundary_parser_)
                this->left_boundary_parser_->pre();

            return true;
        }

        if (n == "right_boundary" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->right_boundary_parser_;

            if (this->right_boundary_parser_)
                this->right_boundary_parser_->pre();

            return true;
        }

        return false;
    }

    bool boundaries_pskel::
    _end_element_impl(const xml_schema::ro_string &ns,
                      const xml_schema::ro_string &n) {
        if (this->xml_schema::complex_content::_end_element_impl(ns, n))
            return true;

        if (n == "top_boundary" && ns.empty()) {
            if (this->top_boundary_parser_)
                this->top_boundary(this->top_boundary_parser_->post_string());

            return true;
        }

        if (n == "bottom_boundary" && ns.empty()) {
            if (this->bottom_boundary_parser_)
                this->bottom_boundary(this->bottom_boundary_parser_->post_string());

            return true;
        }

        if (n == "left_boundary" && ns.empty()) {
            if (this->left_boundary_parser_)
                this->left_boundary(this->left_boundary_parser_->post_string());

            return true;
        }

        if (n == "right_boundary" && ns.empty()) {
            if (this->right_boundary_parser_)
                this->right_boundary(this->right_boundary_parser_->post_string());

            return true;
        }

        return false;
    }

// molecular_pskel
//

    void molecular_pskel::
    cuboid() {
    }

    void molecular_pskel::
    simulation() {
    }

    void molecular_pskel::
    cuboid_input() {
    }

    void molecular_pskel::
    sphere() {
    }

    void molecular_pskel::
    spheres_input() {
    }

    void molecular_pskel::
    boundaries() {
    }

    void molecular_pskel::
    temperature() {
    }

    void molecular_pskel::
    from_checkpoint() {
    }

    void molecular_pskel::
    membrane() {
    }

    void molecular_pskel::
    post_molecular() {
    }

    bool molecular_pskel::
    _start_element_impl(const xml_schema::ro_string &ns,
                        const xml_schema::ro_string &n,
                        const xml_schema::ro_string *t) {
        XSD_UNUSED (t);

        if (this->xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;

        if (n == "cuboid" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->cuboid_parser_;

            if (this->cuboid_parser_)
                this->cuboid_parser_->pre();

            return true;
        }

        if (n == "simulation" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->simulation_parser_;

            if (this->simulation_parser_)
                this->simulation_parser_->pre();

            return true;
        }

        if (n == "cuboid_input" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->cuboid_input_parser_;

            if (this->cuboid_input_parser_)
                this->cuboid_input_parser_->pre();

            return true;
        }

        if (n == "sphere" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->sphere_parser_;

            if (this->sphere_parser_)
                this->sphere_parser_->pre();

            return true;
        }

        if (n == "spheres_input" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->spheres_input_parser_;

            if (this->spheres_input_parser_)
                this->spheres_input_parser_->pre();

            return true;
        }

        if (n == "boundaries" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->boundaries_parser_;

            if (this->boundaries_parser_)
                this->boundaries_parser_->pre();

            return true;
        }

        if (n == "temperature" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->temperature_parser_;

            if (this->temperature_parser_)
                this->temperature_parser_->pre();

            return true;
        }

        if (n == "from_checkpoint" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->from_checkpoint_parser_;

            if (this->from_checkpoint_parser_)
                this->from_checkpoint_parser_->pre();

            return true;
        }

        if (n == "membrane" && ns.empty()) {
            this->xml_schema::complex_content::context_.top().parser_ = this->membrane_parser_;

            if (this->membrane_parser_)
                this->membrane_parser_->pre();

            return true;
        }

        return false;
    }

    bool molecular_pskel::
    _end_element_impl(const xml_schema::ro_string &ns,
                      const xml_schema::ro_string &n) {
        if (this->xml_schema::complex_content::_end_element_impl(ns, n))
            return true;

        if (n == "cuboid" && ns.empty()) {
            if (this->cuboid_parser_) {
                this->cuboid_parser_->post_cuboid();
                this->cuboid();
            }

            return true;
        }

        if (n == "simulation" && ns.empty()) {
            if (this->simulation_parser_) {
                this->simulation_parser_->post_simulation();
                this->simulation();
            }

            return true;
        }

        if (n == "cuboid_input" && ns.empty()) {
            if (this->cuboid_input_parser_) {
                this->cuboid_input_parser_->post_cuboid_input();
                this->cuboid_input();
            }

            return true;
        }

        if (n == "sphere" && ns.empty()) {
            if (this->sphere_parser_) {
                this->sphere_parser_->post_sphere();
                this->sphere();
            }

            return true;
        }

        if (n == "spheres_input" && ns.empty()) {
            if (this->spheres_input_parser_) {
                this->spheres_input_parser_->post_spheres_input();
                this->spheres_input();
            }

            return true;
        }

        if (n == "boundaries" && ns.empty()) {
            if (this->boundaries_parser_) {
                this->boundaries_parser_->post_boundaries();
                this->boundaries();
            }

            return true;
        }

        if (n == "temperature" && ns.empty()) {
            if (this->temperature_parser_) {
                this->temperature_parser_->post_temperature();
                this->temperature();
            }

            return true;
        }

        if (n == "from_checkpoint" && ns.empty()) {
            if (this->from_checkpoint_parser_) {
                this->from_checkpoint_parser_->post_from_checkpoint();
                this->from_checkpoint();
            }

            return true;
        }

        if (n == "membrane" && ns.empty()) {
            if (this->membrane_parser_) {
                this->membrane_parser_->post_membrane();
                this->membrane();
            }

            return true;
        }

        return false;
    }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

